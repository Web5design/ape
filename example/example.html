<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Axonometric Projection</title>
	<style>
		
	body {
		margin: 0px;
	}

	#container {
		position: relative;
	}

	#nodes {
		position: absolute;
		list-style: none;
		padding: 0px;
		margin: 0px;
		left: 0px;
		top: 0px;
	}

	.node {
		color: #fff;
		position: absolute;
		background: #06f;
		opacity: 0.8;
		display: block;
		width: 110px;
		height: 18px;
		margin: -9px 8px;
		border-radius: 10px;
		left: 0px;
		top: 0px;
		font-family: Arial;
		text-transform: uppercase;
		font-size: 11px;
		line-height: 18px;
		text-align: center;
	}

	.node:before {
		content: '';
		display: block;
		width: 10px;
		height: 10px;
		border-radius: 5px;
		position: absolute;
		background: #06f;
		left: -13px;
		top: 4px;
	}
	
	</style>
</head>
<body>
	
	<div id="container">
		<canvas id="canvas" width="1000" height="720"> 
		</canvas>
		<ul id="nodes">
			<li class="node">DOM Element 0</li>
			<li class="node">DOM Element 1</li>
			<li class="node">DOM Element 2</li>
			<li class="node">DOM Element 3</li>
		</ul>
	</div>
	


	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
	<script src="requestAnimationFrame.js"></script>
	<script src="../source/AxonometricProjection.js"></script>
	<script>

	var SIDE = 180;
	var HALF = SIDE * 0.5;

	var $window = $(window);
	var $canvas = $('#canvas');
	var $nodes = $('#nodes .node');

	var context = $canvas[0].getContext('2d');
	var projection = new AxonometricProjection();
	var request = null;
	var rotationStep = 45;
	var pitchStep = 35;
	var path = [];
	var width = 0;
	var height = 0;

	var callbacks = {

		onWindowResize: function(event) {

			resize();
		}
	};

	function resize() {

		width = $window.width();
		height = $window.height();

		$canvas.attr({
			width: width,
			height: height
		});

		projection.origin(width * 0.5, height * 0.5);

		draw();		
	}

	function clear() {
		
		context.clearRect(0, 0, $canvas.width(), $canvas.height());
	}

	function draw() {

		clear();
		drawGrid();
		drawPath();
	}

	function drawGrid() {
		
		var UNIT = 30;
		var COUNT = 20;
		var MAJOR = COUNT * 0.5;
		var SIZE = UNIT * COUNT;
		var X_OFFSET = SIZE * -0.5;
		var Y_OFFSET = SIZE * -0.5;
		var Z_OFFSET = 0;
		
		for (var i = 0, l = COUNT; i <= l; i++) {
					
			var x = {
				a: {
					x: X_OFFSET,
					y: Y_OFFSET + i * UNIT
				},
				b: {
					x: X_OFFSET + SIZE,
					y: Y_OFFSET + i * UNIT
				}
			};
			
			var y = {
				a: {
					x: X_OFFSET + i * UNIT,
					y: Y_OFFSET
				},
				b: {
					x: X_OFFSET + i * UNIT,
					y: Y_OFFSET + SIZE   
				}
			};
			
			var px = {
				a: projection.project(x.a.x, x.a.y, Z_OFFSET),
				b: projection.project(x.b.x, x.b.y, Z_OFFSET)
			};
			
			var py = {
				a: projection.project(y.a.x, y.a.y, Z_OFFSET),
				b: projection.project(y.b.x, y.b.y, Z_OFFSET)
			};

			var minor = i === 0 || i === COUNT ? true : i % MAJOR;
			
			context.beginPath();
			context.moveTo(px.a.x, px.a.y);
			context.lineTo(px.b.x, px.b.y);
			context.moveTo(py.a.x, py.a.y);
			context.lineTo(py.b.x, py.b.y);
			context.strokeStyle = minor ? "#888" : "#08f";
			context.lineWidth = minor ? 0.5 : 1.0;
			context.stroke();
			context.closePath();
		}
	}

	function drawPath() {
		
		context.beginPath();
		
		for (var i = 0, l = path.length; i < l; i++) {
			
			var point3D = path[i];
			var point2D = projection.project(point3D.x, point3D.y, point3D.z);
					
			if (i === 0) {

				context.moveTo(point2D.x, point2D.y);

			} else {

				context.lineTo(point2D.x, point2D.y);
			}
		}
		
		context.strokeStyle = "#f80";
		context.lineJoin = 'round';
		context.lineWidth = 2.0;
		context.miterLimit = 10;
		context.stroke();
		context.closePath();
	}

	function update() {
		
		request = requestAnimationFrame(update);
		
		rotationStep += 0.4;
		pitchStep += 0.008;
			
		projection.rotate(rotationStep);
		projection.pitch(Math.sin(pitchStep) * 90);
		
		$nodes.each(function(index, element) {

			var x = 0;
			var y = 0;
			var z = SIDE;

			switch(index) {
				case 0:
					x = -HALF;
					y = -HALF;
					break;
				case 1:
					x =  HALF;
					y = -HALF;
					break;
				case 2:
					x =  HALF;
					y =  HALF;
					break;
				case 3:
					x = -HALF;
					y =  HALF;
					break;
			}

			var point = projection.project(x, y, z);

			$(element).css({
				left: point.x,
				top: point.y
			});
		});		
		
		draw();
	}

	function initialise() {

		path.push({ x:  HALF,  y:  HALF,  z:  0    });
		path.push({ x:  HALF,  y: -HALF,  z:  0    });
		path.push({ x: -HALF,  y: -HALF,  z:  0    });
		path.push({ x: -HALF,  y: -HALF,  z:  SIDE });
		path.push({ x:  HALF,  y: -HALF,  z:  SIDE });
		path.push({ x:  HALF,  y:  HALF,  z:  SIDE });
		path.push({ x: -HALF,  y:  HALF,  z:  SIDE });
		path.push({ x: -HALF,  y:  HALF,  z:  0    });
		path.push({ x:  HALF,  y:  HALF,  z:  0    });
		
		$window.on('resize', callbacks.onWindowResize)

		resize();
		update();
	}

	initialise();

	</script>
</body>
</html>